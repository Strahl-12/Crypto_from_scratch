from __future__ import annotations
from dataclasses import dataclass
import random

@dataclass
class Curve:
    """
    Elliptic Curve over the field of integers modulo a prime. Points on the curve
    satisfy y^2 = x^3 + a*x +b (mod p )
    """
    p: int #prime modulus of the finite field
    a: int
    b: int

#We take a=0, b=7. Note that these are giving in Hexidecimal. 0x is the indicator for this
bitcoin_curve = Curve(
    p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F,
    a = 0x0000000000000000000000000000000000000000000000000000000000000000,
    b = 0x0000000000000000000000000000000000000000000000000000000000000007
)
# We are thus dealing with the curve: y^2 = x^3 +7 
@dataclass
class Point:
    "An integer point (x,y) on a Curve"
    curve: Curve
    x: int
    y: int

G = Point(
    bitcoin_curve,
    x = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798,
    y = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8
)

print("Generator lies on the curve:", (G.y**2 - G.x**3 - 7) % bitcoin_curve.p == 0 )
random.seed(9000)
x = random.randrange(0, bitcoin_curve.p)
y = random.randrange(0, bitcoin_curve.p)
print("Totally random point lies on the curve:", (y**2 - x**3 -7) % bitcoin_curve.p == 0)


# We take the generator point as a position on the curve from which to start our random walk

@dataclass
class Generator:
    """
    A generator over a curve: an initial point and the (pre-computed) order
    """
    G: Point #  generator point on the curve
    n: int # order of generating point

bitcoin_gen = Generator(
    G=G,
    n  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 #Look into the calculation process of this
)

# Generation of private key
#A private key is an integer satisfyin $1 \leq key \leq n$

secret_key = int.from_bytes(b'Andrej is cool :P', 'big')
assert 1 <= secret_key < bitcoin_gen.n
print(secret_key)

#We are done with private key generation, so we will move onto generating the public key

#The public key is generated by adding the generator to itself "private key" amoutn of times
#that is public_key = secret_key * G
#Note though, that G in R^2 and both public_key, secret_key in R^1
#so what do these operations mean here?

INF = Point(None, None, None) # point at infinity

def extended_euclidian_algorithm(a, b):
    """
    Returns (gcd, x, y) s.t. a * x + b * y == gcd
    This function implements the extended Euclidean
    algorithm and runs in O(log b) in the worst case,
    taken from Wikipedia.
    """
    old_r, r = a, b
    old_s, s = 1, 0
    old_t, t = 0, 1
    while r != 0:
        quotient = old_r // r
        old_r, r = r, old_r - quotient * r
        old_s, s = s, old_s - quotient * s
        old_t, t = t, old_t - quotient * t
    return old_r, old_s, old_t

def inv(n,p):
    """ returns modular multiplicate inverse m s.t. (n * m) % p == 1 """
    gcd, x, y = extended_euclidian_algorithm(n,p)
    return x % p

def elliptic_curve_addition(self, other: Point) -> Point:
    #Special Cases:
    #P + 0 = 0 + P 
    if self == INF:
        return other
    if other ==INF:
        return self
    # P + (-P) = 0
    if self.x == other.x and self.y != other.y:
        return INF
    #compute the "slope"
    if self.x == other.x:
        m = (3*self.x**2 + self.curve.a)**inv(2*self.y, self.curve.p)
    else:
        m = (self.y - other.y) * inv(self.x - other.x, self.curve.p)
    #compute the new point
    rx = (m**2 - self.x - other.x) % self.curve.p
    ry = (-(m*(rm - self.x) + self.y)) % self.curve.p
    return Point(self.curve, rx, ry)

Point.__add__ = elliptic_curve_addition